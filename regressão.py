# -*- coding: utf-8 -*-
"""regressão linear(simples).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1NX_krARLbJEzAWIkotBHlYQUIgMRwL-B

# Bibliotecas - Intalações
"""

!pip install --upgrade -q pandas

"""# Bibliotecas"""

import pandas as pd
import math

"""# Classes"""

class Coordenada:
  def __init__(self, valores):
    self.valores = valores

  def somatoria(self) -> float:
    return sum(self.valores)

  def mostrar_valores(self) -> list:
    return self.valores

  def media_valores(self, n) -> float:
    return float(self.somatoria() / n)

  def somatoria_seg(self) -> float:
    numeros = []
    for i in range(len(self.mostrar_valores())):
      numeros.append(self.mostrar_valores()[i] * self.mostrar_valores()[i])
    return sum(numeros)

"""# Métodos"""

def pegar_somatorio_xy(n: int, x: Coordenada, y: Coordenada) -> float:
  """
  Multiplica X com seu valor par de Y.

  Args:
      n (int): O número total de pontos de dados.
      x (Coordenada): O objeto Coordenada dos valores de X.
      y (Coordenada): O objeto Coordenada dos valores de Y.
  """
  multi = []
  for i in range(0, n):
    if i is not None:
      multi.append(x.mostrar_valores()[i] * y.mostrar_valores()[i])
  return float(sum(multi))

def inclinacao(n: int, x: Coordenada, y: Coordenada) -> float:
  """
  Calcula o coeficiente 'b' (inclinação) da regressão linear.

  Args:
      n (int): O número total de pontos de dados.
      x (Coordenada): O objeto Coordenada dos valores de X.
      y (Coordenada): O objeto Coordenada dos valores de Y.
  """
  numerador = (n * pegar_somatorio_xy(n, x, y)) - (x.somatoria() * y.somatoria())
  denominador = (n * x.somatoria_seg()) - (x.somatoria() * x.somatoria())
  divisao = numerador / denominador
  return divisao

def interseccao(n, x, y) -> float:
  """
  Calcula o coeficiente 'a' (intercepto) da regressão linear.

  Args:
      n (int): O número total de pontos de dados.
      x (Coordenada): O objeto Coordenada dos valores de X.
      y (Coordenada): O objeto Coordenada dos valores de Y.
  """
  numerador = y.media_valores(n) - (inclinacao(n, x, y) * x.media_valores(n))
  return numerador

def prever(a: float, b: float, valor_a_prever: float) -> float:
  """
  Calcula a previsão da regressão linear.

  Args:
      a (float): Coeficiente A.
      b (float): Coeficiente B.
      valor_a_prever (float): Valor que deseja realizar a previsão.
  """
  numerador = a + (b * valor_a_prever)
  return numerador

def correlacao(n: int, x: Coordenada, y: Coordenada) -> float:
  """
  Calcula o Coeficiente de Correlação (R) de Pearson.

  Args:
      n (int): O número total de pontos de dados.
      x (Coordenada): O objeto Coordenada dos valores de X.
      y (Coordenada): O objeto Coordenada dos valores de Y.
  """
  numerador = (n * pegar_somatorio_xy(n, x, y)) - (x.somatoria() * y.somatoria())
  calc1 = (n * x.somatoria_seg()) - (x.somatoria() * x.somatoria())
  calc2 = (n * y.somatoria_seg()) - (y.somatoria() * y.somatoria())
  denominador = math.sqrt(calc1 * calc2)
  return numerador / denominador

"""# Pegando coordenadas"""

df = pd.read_csv('/content/dados-80.csv')

df.columns = df.columns.str.strip()
n = len(df['Valor_RS'].tolist())

x = Coordenada(df["Peso_g"].tolist())
y = Coordenada(df["Valor_RS"].tolist())

a = interseccao(n, x, y)
b = inclinacao(n, x, y)

r = correlacao(n, x, y)
v_absoluto = abs(r)

if v_absoluto < 0.25:
    forca = "Inexistente"
elif v_absoluto < 0.5:
    forca = "Fraca"
elif v_absoluto < 0.7:
    forca = "Moderada"
elif v_absoluto < 1:
    forca = "Forte"
else:
    forca = "Perfeita"

df

"""# Executando codigo"""

print("------ MODELO ------\n")
print(f"R ({forca}): {r:.2f}")
print(f"R²: {(r * r):.2f} de precisão")
print("Digite [0] Para encerrar")
print("\n")

while True:
  nome_produto = input("Qual o nome do produto: ")
  peso = float(input("Informe o peso do produto: "))

  if nome_produto == "0" or peso == 0:
    break

  print(f"Valor do produto: R${prever(a, b, peso):.2f}\n")